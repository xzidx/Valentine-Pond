\<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>monika Â· nang</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      background: #1a3e3f;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Segoe UI', 'Courier New', monospace;
      padding: 8px;
      touch-action: pan-x pan-y;
    }
    .frame {
      background: #2c5e5e;
      padding: 12px;
      border-radius: 36px 36px 24px 24px;
      box-shadow: 0 20px 30px rgba(0,0,0,0.5);
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }
    .pond-container {
      position: relative;
      border-radius: 28px;
      overflow: hidden;
      box-shadow: inset 0 0 20px #0e2a2a;
      width: 100%;
      aspect-ratio: 500 / 400;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 50% 40%, #1f6f5e, #15423b);
      cursor: pointer;
      touch-action: none;
    }
  </style>
</head>
<body>
<div class="frame">
  <div class="pond-container">
    <canvas id="pondCanvas" width="500" height="400"></canvas>
  </div>
</div>
<script>
  const canvas = document.getElementById('pondCanvas');
  const ctx = canvas.getContext('2d');

  // ----------  LEAVES - ADAPTED FOR SMALLER CANVAS ----------
  const leaves = [];
  const LEAVES_COUNT = 30;

  for (let i = 0; i < LEAVES_COUNT; i++) {
    leaves.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: 8 + Math.random() * 14,
      speedX: 0.015 + Math.random() * 0.04,
      speedY: 0.01 + Math.random() * 0.03,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.0012,
      opacity: 0.5 + Math.random() * 0.3,
      color: `rgba(${200 + Math.floor(Math.random()*35)}, ${125 + Math.floor(Math.random()*30)}, ${85 + Math.floor(Math.random()*30)}, 0.6)`
    });
  }

  // ----------  FISH - SMALLER FOR MOBILE ----------
  let monika = {
    x: 280, y: 200,
    vx: 0, vy: 0,
    angle: 1.8,
    targetAngle: 1.8,
    targetX: 300, targetY: 180,
    bodyLength: 32,
    tailPhase: 0,
    name: 'Monika',
    messageTimer: 0,
    currentMessage: ''
  };

  let nang = {
    x: 240, y: 185,
    vx: 0, vy: 0,
    angle: 1.7,
    targetAngle: 1.7,
    bodyLength: 28,
    tailPhase: 0,
    name: 'Nang',
    messageTimer: 0,
    currentMessage: ''
  };

  // ----------  NANG'S 15 SPECIAL LINES ----------
  const nangMessages = [
    "cute mes pp sml bong",
    "som kiss muy mk oun ery",
    "smile dak bong jg kon yg dak name ey tv hr ?",
    "Kom run jrol bong merl ha",
    "Slanh bong heh",
    "Som kiss muy merl ha",
    "pp bong lren cute mg ha",
    "hue mix run jrol bong jg ha T-T",
    "Slanh pp bong mg ha :3",
    "Kert che ey bong nv ta slanh oun del",
    "Oun che fish kr nv ta cute",
    "Run jrol bong tt hz",
    "slanh bong ot ha ?",
    "hue kom run merl som kiss tix mk",
    "ot kiss pd oun eng heh"
  ];

  // ----------  MONIKA'S 12 LINES ----------
  const monikaMessages = [
    "bork oun tt hz",
    "lie oun sos ng",
    "ot ban run jrol heh",
    "kom mk bork oun hr",
    "vai nogh lov hz",
    "slanh sos ng ha",
    "trov bos oun lov hz",
    "kom mk jit oun",
    "bork oun tt hz",
    "lie oun sos ng",
    "ot ban run jrol heh",
    "kom mk bork oun hr"
  ];

  // monika's targets - closer together for mobile
  function setNewMonikaTarget() {
    monika.targetX = 60 + Math.random() * (canvas.width - 120);
    monika.targetY = 50 + Math.random() * (canvas.height - 100);
  }
  setNewMonikaTarget();
  setInterval(setNewMonikaTarget, 4800);

  // ----------  REAL FISH FOLLOWING - ADJUSTED FOR SMALLER SCALE ----------
  const TURN_SPEED = 0.016;
  const MONIKA_SPEED = 0.42;
  
  const IDEAL_DISTANCE = 45;
  const TOO_CLOSE = 28;
  const FOLLOW_STRENGTH = 0.0055;
  
  function smoothSwim() {
    // ----- MONIKA -----
    let dx = monika.targetX - monika.x;
    let dy = monika.targetY - monika.y;
    let dist = Math.hypot(dx, dy);
    
    if (dist > 2) {
      let normX = dx / dist;
      let normY = dy / dist;
      monika.vx += (normX * MONIKA_SPEED - monika.vx) * 0.06;
      monika.vy += (normY * MONIKA_SPEED - monika.vy) * 0.06;
      monika.targetAngle = Math.atan2(monika.vy, monika.vx);
    } else {
      monika.vx *= 0.97;
      monika.vy *= 0.97;
    }
    
    monika.x += monika.vx;
    monika.y += monika.vy;
    
    // boundaries
    if (monika.x < 35) { monika.vx += 0.08; monika.targetX = canvas.width - 80; }
    if (monika.x > canvas.width - 35) { monika.vx -= 0.08; monika.targetX = 80; }
    if (monika.y < 35) { monika.vy += 0.08; monika.targetY = canvas.height - 80; }
    if (monika.y > canvas.height - 35) { monika.vy -= 0.08; monika.targetY = 80; }
    
    monika.x = Math.min(Math.max(monika.x, 35), canvas.width - 35);
    monika.y = Math.min(Math.max(monika.y, 35), canvas.height - 35);
    
    // monika turn
    if (Math.hypot(monika.vx, monika.vy) > 0.1) {
      let angleDiff = monika.targetAngle - monika.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      monika.angle += angleDiff * TURN_SPEED;
    }
    
    // ----- NANG - FOLLOW MONIKA NATURALLY -----
    let dxN = monika.x - nang.x;
    let dyN = monika.y - nang.y;
    let distN = Math.hypot(dxN, dyN);
    
    if (distN > 0.1) {
      let normXN = dxN / distN;
      let normYN = dyN / distN;
      
      // if too far, move closer
      if (distN > IDEAL_DISTANCE) {
        let pull = FOLLOW_STRENGTH * (distN / IDEAL_DISTANCE);
        nang.vx += normXN * pull * distN * 0.16;
        nang.vy += normYN * pull * distN * 0.16;
      }
      
      // if too close, move away
      if (distN < TOO_CLOSE) {
        let push = 0.08 * (1 - distN / TOO_CLOSE);
        nang.vx -= normXN * push;
        nang.vy -= normYN * push;
      }
      
      // at good distance, gentle speed match
      if (distN >= TOO_CLOSE && distN <= IDEAL_DISTANCE) {
        nang.vx += (monika.vx * 0.3 - nang.vx) * 0.018;
        nang.vy += (monika.vy * 0.3 - nang.vy) * 0.018;
      }
    }
    
    // individual movement
    nang.vx += Math.sin(Date.now() * 0.001 + nang.x) * 0.006;
    nang.vy += Math.cos(Date.now() * 0.0011 + nang.y) * 0.006;
    
    // damping
    nang.vx *= 0.98;
    nang.vy *= 0.98;
    
    nang.x += nang.vx;
    nang.y += nang.vy;
    
    // boundaries
    nang.x = Math.min(Math.max(nang.x, 35), canvas.width - 35);
    nang.y = Math.min(Math.max(nang.y, 35), canvas.height - 35);
    
    // nang turn
    if (Math.hypot(nang.vx, nang.vy) > 0.1) {
      nang.targetAngle = Math.atan2(nang.vy, nang.vx);
      let angleDiffN = nang.targetAngle - nang.angle;
      while (angleDiffN > Math.PI) angleDiffN -= Math.PI * 2;
      while (angleDiffN < -Math.PI) angleDiffN += Math.PI * 2;
      nang.angle += angleDiffN * 0.016;
    }
    
    // tails
    monika.tailPhase = (monika.tailPhase + 0.1) % (Math.PI * 2);
    nang.tailPhase = (nang.tailPhase + 0.12) % (Math.PI * 2);
    
    // ----- BOTH FISH SPEAK -----
    // Nang speaks
    nang.messageTimer--;
    if (nang.messageTimer <= 0) {
      let msgIndex = Math.floor(Math.random() * nangMessages.length);
      nang.currentMessage = nangMessages[msgIndex];
      nang.messageTimer = 70 + Math.floor(Math.random() * 50);
    }
    
    // Monika speaks
    monika.messageTimer--;
    if (monika.messageTimer <= 0) {
      let msgIndex = Math.floor(Math.random() * monikaMessages.length);
      monika.currentMessage = monikaMessages[msgIndex];
      monika.messageTimer = 90 + Math.floor(Math.random() * 60);
    }
  }

  function drawPond() {
    smoothSwim();
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // water
    ctx.fillStyle = 'rgba(240, 250, 230, 0.02)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ----- LEAVES -----
    for (let l of leaves) {
      l.x += l.speedX;
      l.y += l.speedY;
      l.rotation += l.rotSpeed;
      
      if (l.x > canvas.width + 40) l.x = -40;
      if (l.x < -40) l.x = canvas.width + 40;
      if (l.y > canvas.height + 40) l.y = -40;
      if (l.y < -40) l.y = canvas.height + 40;
      
      ctx.save();
      ctx.translate(l.x, l.y);
      ctx.rotate(l.rotation);
      ctx.globalAlpha = l.opacity * 0.8;
      ctx.fillStyle = l.color;
      ctx.shadowBlur = 4;
      ctx.shadowColor = 'rgba(80, 40, 20, 0.2)';
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(l.size * 0.4, -l.size * 0.5, l.size * 0.9, 0);
      ctx.quadraticCurveTo(l.size * 0.4, l.size * 0.5, 0, 0);
      ctx.fill();
      ctx.restore();
    }
    
    // ----- MONIKA with NAME and SPEECH -----
    ctx.save();
    ctx.translate(monika.x, monika.y);
    ctx.rotate(monika.angle);
    
    let gradient = ctx.createLinearGradient(-12, -5, 12, 5);
    gradient.addColorStop(0, '#ffaa80');
    gradient.addColorStop(1, '#ff8c69');
    ctx.fillStyle = gradient;
    ctx.shadowBlur = 12;
    ctx.shadowColor = 'rgba(255, 140, 100, 0.5)';
    
    ctx.beginPath();
    ctx.ellipse(0, 0, monika.bodyLength/2, monika.bodyLength/4.2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#ff7f50';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(-monika.bodyLength/2 + 4, -2);
    ctx.lineTo(-monika.bodyLength/2 - 10 + Math.sin(monika.tailPhase) * 2.5, -9);
    ctx.lineTo(-monika.bodyLength/2 - 10 + Math.cos(monika.tailPhase) * 2, 9);
    ctx.closePath();
    ctx.fill();
    
    ctx.shadowBlur = 2;
    ctx.beginPath();
    ctx.arc(monika.bodyLength/5, -2, 2.2, 0, 2 * Math.PI);
    ctx.fillStyle = '#1e1e2a';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(monika.bodyLength/5 + 0.8, -2.4, 0.9, 0, 2*Math.PI);
    ctx.fillStyle = 'white';
    ctx.fill();
    
    // MONIKA NAME - smaller for mobile
    ctx.shadowBlur = 6;
    ctx.font = 'bold 14px "Courier New", monospace';
    ctx.fillStyle = '#fff9f0';
    ctx.fillText('ðŸŒ¸ Monika', 20, -28);
    
    ctx.restore();
    
    // ----- NANG with NAME -----
    ctx.save();
    ctx.translate(nang.x, nang.y);
    ctx.rotate(nang.angle);
    
    let gradientN = ctx.createLinearGradient(-10, -4, 10, 4);
    gradientN.addColorStop(0, '#6aaac9');
    gradientN.addColorStop(1, '#4682b4');
    ctx.fillStyle = gradientN;
    ctx.shadowBlur = 12;
    ctx.shadowColor = 'rgba(70, 130, 180, 0.5)';
    
    ctx.beginPath();
    ctx.ellipse(0, 0, nang.bodyLength/2, nang.bodyLength/4.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#2e5e7e';
    ctx.beginPath();
    ctx.moveTo(-nang.bodyLength/2 + 4, -2);
    ctx.lineTo(-nang.bodyLength/2 - 11 + Math.sin(nang.tailPhase) * 2.5, -8);
    ctx.lineTo(-nang.bodyLength/2 - 11 + Math.cos(nang.tailPhase) * 2, 8);
    ctx.closePath();
    ctx.fill();
    
    ctx.shadowBlur = 2;
    ctx.beginPath();
    ctx.arc(nang.bodyLength/5, -2, 2.0, 0, 2 * Math.PI);
    ctx.fillStyle = '#151525';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(nang.bodyLength/5 + 0.7, -2.4, 0.7, 0, 2*Math.PI);
    ctx.fillStyle = 'white';
    ctx.fill();
    
    // NANG NAME - smaller for mobile
    ctx.shadowBlur = 6;
    ctx.font = 'bold 14px "Courier New", monospace';
    ctx.fillStyle = '#fff5e6';
    ctx.fillText('ðŸ’™ Nang', -48, -32);
    
    ctx.restore();
    
    // ----- MONIKA'S SPEECH BUBBLE - SMALLER FOR MOBILE -----
    if (monika.currentMessage && monika.messageTimer > 0) {
      ctx.save();
      
      let bubbleX = monika.x;
      let bubbleY = monika.y - 70;
      
      ctx.font = '13px "Courier New", monospace';
      let textWidth = ctx.measureText(monika.currentMessage).width;
      let bubbleWidth = Math.max(textWidth + 24, 180);
      let bubbleHeight = 36;
      
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.fillStyle = 'rgba(255, 240, 240, 0.98)';
      ctx.strokeStyle = '#ffb7c5';
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.roundRect(bubbleX - bubbleWidth/2, bubbleY - bubbleHeight/2, bubbleWidth, bubbleHeight, 18);
      ctx.fill();
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(bubbleX - 10, bubbleY + bubbleHeight/2 - 2);
      ctx.lineTo(bubbleX, bubbleY + bubbleHeight/2 + 14);
      ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight/2 - 2);
      ctx.fillStyle = 'rgba(255, 240, 240, 0.98)';
      ctx.fill();
      
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#4a2a3a';
      ctx.font = 'bold 13px "Courier New", monospace';
      ctx.fillText(monika.currentMessage, bubbleX - textWidth/2, bubbleY + 6);
      
      ctx.restore();
    }
    
    // ----- NANG'S SPEECH BUBBLE - SMALLER FOR MOBILE -----
    if (nang.currentMessage && nang.messageTimer > 0) {
      ctx.save();
      
      let bubbleX = nang.x;
      let bubbleY = nang.y - 70;
      
      ctx.font = '13px "Courier New", monospace';
      let textWidth = ctx.measureText(nang.currentMessage).width;
      let bubbleWidth = Math.max(textWidth + 24, 200);
      let bubbleHeight = 36;
      
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.fillStyle = 'rgba(235, 245, 255, 0.98)';
      ctx.strokeStyle = '#a5c5ff';
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.roundRect(bubbleX - bubbleWidth/2, bubbleY - bubbleHeight/2, bubbleWidth, bubbleHeight, 18);
      ctx.fill();
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(bubbleX - 10, bubbleY + bubbleHeight/2 - 2);
      ctx.lineTo(bubbleX, bubbleY + bubbleHeight/2 + 14);
      ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight/2 - 2);
      ctx.fillStyle = 'rgba(235, 245, 255, 0.98)';
      ctx.fill();
      
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#2a3a4a';
      ctx.font = 'bold 13px "Courier New", monospace';
      ctx.fillText(nang.currentMessage, bubbleX - textWidth/2, bubbleY + 6);
      
      ctx.restore();
    }
    
    // ----- HEARTS - BETWEEN THEM -----
    let distBetween = Math.hypot(monika.x - nang.x, monika.y - nang.y);
    if (distBetween > TOO_CLOSE && distBetween < IDEAL_DISTANCE + 20 && Math.random() < 0.18) {
      ctx.save();
      let heartX = (monika.x + nang.x) / 2 + (Math.random() - 0.5) * 20;
      let heartY = (monika.y + nang.y) / 2 + (Math.random() - 0.5) * 18 - 5;
      ctx.translate(heartX, heartY);
      ctx.font = '18px "Segoe UI", sans-serif';
      ctx.fillStyle = 'rgba(255, 130, 160, 0.85)';
      ctx.shadowBlur = 16;
      ctx.shadowColor = '#ff6f91';
      ctx.fillText('â¤ï¸', -10, -10);
      ctx.restore();
    }
    
    requestAnimationFrame(drawPond);
  }

  // Helper function
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    return this;
  };

  // ----------  TOUCH SUPPORT FOR MOBILE ----------
  function handleTouch(e) {
    e.preventDefault();
    let rect = canvas.getBoundingClientRect();
    let touch = e.touches[0];
    let scaleX = canvas.width / rect.width;
    let scaleY = canvas.height / rect.height;
    let canvasX = (touch.clientX - rect.left) * scaleX;
    let canvasY = (touch.clientY - rect.top) * scaleY;
    
    // keep within bounds
    canvasX = Math.min(Math.max(canvasX, 40), canvas.width - 40);
    canvasY = Math.min(Math.max(canvasY, 40), canvas.height - 40);
    
    monika.targetX = canvasX;
    monika.targetY = canvasY;
  }

  canvas.addEventListener('touchstart', handleTouch, { passive: false });
  canvas.addEventListener('touchmove', handleTouch, { passive: false });
  
  // mouse support still works
  canvas.addEventListener('click', (e) => {
    let rect = canvas.getBoundingClientRect();
    let scaleX = canvas.width / rect.width;
    let scaleY = canvas.height / rect.height;
    let canvasX = (e.clientX - rect.left) * scaleX;
    let canvasY = (e.clientY - rect.top) * scaleY;
    
    monika.targetX = canvasX;
    monika.targetY = canvasY;
  });

  drawPond();

</script>
</body>
</html>